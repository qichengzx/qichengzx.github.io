
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>

  启程
  

</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<link href="/css/style.css" rel="stylesheet" type="text/css">
<meta property="og:type" content="website">
<meta property="og:title" content="启程">
<meta property="og:url" content="https://qichengzx.github.io">
<meta property="og:site_name" content="启程">
<meta property="og:description" content="记录写代码过程中的成长，不要把你仅知道的那一点点东西当成全世界">
<link rel="icon" href="/favicon.ico">

</head>
<body>
<div id="container">
  <div id="wrap">
    
        <header id="header">
          <div id="banner"></div>
          <div id="header-outer" class="outer">
            <div id="header-title" class="inner">
              <h1 id="logo-wrap">
                <a href="https://qichengzx.github.io" id="logo">启程</a>
              </h1>
              
            </div>
            <div id="header-inner" class="inner">
              <nav id="main-nav">
                <a id="main-nav-toggle" class="nav-icon"></a>
                
                <a class="main-nav-link" href="/">Home</a>
                
                <a class="main-nav-link" href="/archives">Archives</a>
                
                <a class="main-nav-link" href="https://github.com/qichengzx">GitHub</a>
                
              </nav>
              <nav id="sub-nav">
              
                <a id="nav-search-btn" class="nav-icon" title="Search"></a>
              </nav>
              <div id="search-form-wrap">
                <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form">
                  <input type="search" name="q" class="search-form-input" placeholder="Search">
                  <button type="submit" class="search-form-submit">&#xF002;</button>
                  <input type="hidden" name="sitesearch" value="https://qichengzx.github.io">
                </form>
              </div>
            </div>
          </div>
        </header>

    <div class="outer">
      <section id="main">
      
        
        
                <article id="9ea3b5631aa06bd499297293aeb51d6a" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://qichengzx.github.io/2017/09/17/redis-geo-with-redigo-in-golang-part-1.html" class="article-date">
                      <time itemprop="datePublished">2017-09-17 19:45:29</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://qichengzx.github.io/2017/09/17/redis-geo-with-redigo-in-golang-part-1.html">Go语言使用redigo操作GEO(1) - 添加和查询</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p>周五的时候群里有人遇到在Go中使用Redis GEO的问题，顺手搜了下解决办法。发现还挺简单的，周末无事，写下来记一下。</p>

<p>GEO是在Redis 3.2加入的功能，手册<a href="http://redisdoc.com/geo/index.html">见此</a></p>

<p>本示例中只演示GEOADD和GEOPOS功能。</p>

<p><a href="https://github.com/garyburd/redigo/tree/master/redis">redigo</a>这个客户端还挺好用的，但是个人觉得略有不足的是文档不全（指的是中文的文档），但是好在可以看源码解决一些不太清楚的问题。</p>

<h4>0.连接Redis</h4>

<p>首先习惯性的创建了连接池，嗯，连接池。</p>

<pre><code class="language-Go">func init() {
	RedisClient = &amp;redis.Pool{
		MaxIdle:   MaxIdle,
		MaxActive: MaxActive,

		IdleTimeout: 60 * time.Second,

		Dial: func() (redis.Conn, error) {
			c, err := redis.Dial(&quot;tcp&quot;, RedisHost)

			if err != nil {
				return nil, err
			}

			/*if _, err := c.Do(&quot;AUTH&quot;, RedisPwd); err != nil {
				c.Close()
				return nil, err
			}*/
			c.Do(&quot;SELECT&quot;, RedisDb)

			return c, nil
		},
	}
}
</code></pre>

<h4>1.添加值</h4>

<p>为了简单起见，创建了一个方法用于向传入的key中写入name的坐标点。</p>

<p>直接返回错误。</p>

<pre><code class="language-Go">func push(key, name string, lat, lng float64) error {
	rc := RedisClient.Get()
	defer rc.Close()

	_, err := rc.Do(&quot;GEOADD&quot;, key, lng, lat, name)
	return err
}

</code></pre>

<h4>2.取回值</h4>

<p>同样，创建一个方法，在Redis中取回key中name的坐标点的值。</p>

<p>但是注意，这里在执行完 <code>GEOPOS</code> 后，调用 redigo 包中的 <code>Positions</code> 方法把返回结果转成 <code>float64</code> 的数组。</p>

<p>然后返回这个数组和错误</p>

<pre><code class="language-Go">func get(key, name string) ([]*[2]float64, error) {
	rc := RedisClient.Get()
	defer rc.Close()

	res, err := redis.Positions(rc.Do(&quot;GEOPOS&quot;, key, name))

	return res, err
}
</code></pre>

<h4>3.main方法中的简单代码</h4>

<pre><code class="language-Go">func main() {
	key := &quot;citylist&quot;
	name := &quot;beijing&quot;
	lat := 39.9329
	lng := 116.280316
	err := push(key, name, lat, lng)
	if err != nil {
		panic(err)
	}
	fmt.Println(&quot;坐标写入完成&quot;)
	fmt.Println(&quot;获取刚刚写入的值&quot;)

	res, err := get(key, name)
	if err != nil {
		panic(err)
	}
	fmt.Println(res[0][0], res[0][1])
}
</code></pre>

<p>就这么简单。</p>

<p>import部分和定义的几个全局变量就不用写了，</p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://qichengzx.github.io/2017/09/17/redis-geo-with-redigo-in-golang-part-1.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/redis">redis</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/redigo">redigo</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/geo">geo</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="5876f4d8a7d4aaa11e4c60f44565d74d" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://qichengzx.github.io/2017/08/13/leetcode-array-partition-i.html" class="article-date">
                      <time itemprop="datePublished">2017-08-13 10:14:49</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://qichengzx.github.io/2017/08/13/leetcode-array-partition-i.html">LeetCode 561.Array Partition I(数组分区 1) - Go实现</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p>题目地址:<a href="https://leetcode.com/problems/array-partition-i/description/">561. Array Partition I</a></p>

<p>题目描述：</p>

<p>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), &hellip;, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>

<h6>Example 1:</h6>

<pre><code>Input: [1,4,3,2]

Output: 4

Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).
</code></pre>

<h6>Note:</h6>

<p>​   n is a positive integer, which is in the range of [1, 10000].
​   All the integers in the array will be in the range of [-10000, 10000].</p>

<p>题目大意：</p>

<p>给定一个长度为2n的数组，要把它分成n个分组，即每组有两个数，返回每组中最小值的总和，使和最大。</p>

<p>理解了大意就知道思路了，又看了下论坛里的<a href="https://discuss.leetcode.com/topic/87206/java-solution-sorting-and-rough-proof-of-algorithm">算法分析</a></p>

<p>解决方案基本就是先按从小到大排序，这样相邻的数字是最接近的，然后再分成两两一组，取每组中的第一个数相加即可。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	nums := []int{4, 5, 6, 1}
	n := arrayPairSum(nums)
	fmt.Println(n)
}

func arrayPairSum(nums []int) int {
	sort.Ints(nums)
	sum := 0
	length := len(nums)
	for i := 0; i &lt; length; i += 2 {
		sum += nums[i]
	}
	return sum
}
</code></pre>

<p>在线查看结果:<a href="https://play.golang.org/p/2tkZyayXUB">The Go Playground</a></p>

<p>其实这里主要用到了Go的<a href="https://golang.org/pkg/sort/#Ints">sort包给int数组排序</a>。排序后遍历数组，每次递增2就可以了。</p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://qichengzx.github.io/2017/08/13/leetcode-array-partition-i.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/leetcode">leetcode</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="5192917a0bda629bc983c4230592edb7" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://qichengzx.github.io/2017/07/15/create-real-time-chat-app-golang-angular-2-websockets.html" class="article-date">
                      <time itemprop="datePublished">2017-07-15 12:11:14</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://qichengzx.github.io/2017/07/15/create-real-time-chat-app-golang-angular-2-websockets.html">【译】使用Go和Angular通过WebSocket构建实时聊天应用</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <h3>写在前面</h3>

<p>本文<a href="https://www.thepolyglotdeveloper.com/2016/12/create-real-time-chat-app-golang-angular-2-websockets/">原文</a>，详细讲解了如何使用Go和Angular通过WebSocket构建实时聊天应用。</p>

<h4>正文</h4>

<p>我最近听到很多关于WebSocket的东西，以及WebSocket如何在应用程序和服务器之间实现实时通信。WebSocket作为RESTful API的替代和补充，已经存在了很长时间。使用WebSocket可以做例如实时聊天，与IoT通信，游戏，和其他很多需要在客户端和服务器之间进行即时消息传递的东西。</p>

<p>最近一段时间，我<a href="https://www.thepolyglotdeveloper.com/2016/01/create-a-real-time-chat-application-with-the-cean-stack-and-socket-io/">使用了一个叫Socket.io的库，用来在Node.js中使用websockets</a>，但是当我真正使用Go以后，我打算研究一下如何在Go中使用WebSocket。</p>

<p>通过本文，我们将学习如何创建一个聊天应用，其中客户端是一个 Angular 2 应用，服务端使用Go。</p>

<h4>要求</h4>

<p>在这个应用中有很多操作，所以有一些必要的前提条件，如下所示：</p>

<ul>
<li><a href="https://golang.org/">Go</a> 1.7+</li>
<li><a href="https://nodejs.org/en/">Node.js</a> 4.0+</li>
<li><a href="https://cli.angular.io/">Angular2 CLI</a></li>
</ul>

<p>处理所有消息和客户端的聊天服务器使用Go编写。客户端前端使用 Angular 2编写，has a dependency of the Node Package Manager (NPM) which ships with Node.js.</p>

<h4>创建Go聊天服务器</h4>

<p>我们打算先开发整个应用的服务器端部分，它需要依赖几个第三方的包。</p>

<p>在命令行执行以下命令，下载第三方包：</p>

<pre><code class="language-go">//Install Go Dependencies
go get github.com/gorilla/websocket
go get github.com/satori/go.uuid
</code></pre>

<p>websocket包的作者同时也是 <a href="https://github.com/gorilla/mux">Mux</a> 这个路由包 的作者，我们还需要一个UUID包来分配每一个客户端的唯一ID。</p>

<p>在 $GOPATH 目录创建一个新的项目，我自己的项目目录是 $GOPATH/src/github.com/nraboy/realtime-chat/main.go。</p>

<p>在进行下一步之前，需要注意的是，我从 <a href="https://dinosaurscode.xyz/go/2016/07/17/go-websockets-tutorial/">Dinosaurs Code</a> 和 <a href="https://github.com/gorilla/websocket/tree/master/examples/chat">Gorilla websocket chat example</a>  获取了一部分Go 代码，为了避免剽窃的嫌疑，我使用了很多原始代码中的一部分，但我也为这个项目加入了很多自己的独特的东西。</p>

<p>这次我们要做的聊天应用有3个结构体：</p>

<pre><code class="language-go">// $GOPATH/src/github.com/nraboy/realtime-chat/main.go
type ClientManager struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}
 
type Client struct {
    id     string
    socket *websocket.Conn
    send   chan []byte
}
 
type Message struct {
    Sender    string `json:&quot;sender,omitempty&quot;`
    Recipient string `json:&quot;recipient,omitempty&quot;`
    Content   string `json:&quot;content,omitempty&quot;`
}
</code></pre>

<p>ClientManager用于管理所有已连接的客户端，尝试连接的客户端，已经断开连接等待删除的客户端，和所有已连接客户端收发的消息。</p>

<p>每个客户端有一个唯一的ID，一个socket连接，和等待发送的消息。</p>

<p>为了增加传递的数据的复杂性，消息将使用 JSON 格式。而不是传递一串不容易被理解，阅读的数据。使用JSON格式，我们可以使用元数据和其他有用的东西。每一条消息将包含发送消息的客户端，接收消息的客户端，和消息的实际内容。</p>

<p>首先定义一个全局的ClientManager。</p>

<pre><code class="language-go">//$GOPATH/src/github.com/nraboy/realtime-chat/main.go
var manager = ClientManager{
    broadcast:  make(chan []byte),
    register:   make(chan *Client),
    unregister: make(chan *Client),
    clients:    make(map[*Client]bool),
}
</code></pre>

<p>服务器端将使用3个goroutine，一个用于管理客户端，一个用于读取websocket数据，另一个用于往websocket里写数据。这里指的是读取和写入的goroutine将为每个连接的客户端创建一个新的实例。所有的goroutine将循环运行直至不再需要。</p>

<p>编写如下代码，来开始服务：</p>

<pre><code class="language-go">//$GOPATH/src/github.com/nraboy/realtime-chat/main.go
func (manager *ClientManager) start() {
    for {
        select {
        case conn := &lt;-manager.register:
        	manager.clients[conn] = true
        	jsonMessage, _ := json.Marshal(&amp;Message{Content: &quot;/A new socket has connected.&quot;})
            manager.send(jsonMessage, conn)
        case conn := &lt;-manager.unregister:
            if _, ok := manager.clients[conn]; ok {
                close(conn.send)
                delete(manager.clients, conn)
                jsonMessage, _ := json.Marshal(&amp;Message{Content: &quot;/A socket has disconnected.&quot;})
                manager.send(jsonMessage, conn)
            }
        case message := &lt;-manager.broadcast:
            for conn := range manager.clients {
                select {
                case conn.send &lt;- message:
                default:
                    close(conn.send)
                    delete(manager.clients, conn)
                }
            }
        }
    }
}
</code></pre>

<p>每当 manager.register 接收到数据，这个正在建立连接的客户端将会被添加到 manager (前文创建的 ClientManager 实例)的 clients 中。然后，将向所有其他客户端发送一条JSON消息。</p>

<p>同时，如果客户端断开连接，manager.unregister channel将会收到消息，断开连接的客户端的 channel 中的数据将被关闭，客户端也会从manager中删除。然后发送消息给其他的客户端告知某个客户端已断开连接。</p>

<p>如果 manager.broadcast channel 中存在数据，则表示正在尝试发送和接收消息。我们打算遍历每个已连接的客户端，将消息发送给它们。如果由于某些原因，channel 被阻塞或消息无法发送，我们会认为这个客户端已断开连接，然后将其删除。</p>

<p>为了使代码简洁，创建一个 manager.send 方法遍历每个客户端。</p>

<pre><code class="language-go">//$GOPATH/src/github.com/nraboy/realtime-chat/main.go
func (manager *ClientManager) send(message []byte, ignore *Client) {
    for conn := range manager.clients {
        if conn != ignore {
            conn.send &lt;- message
        }
    }
}
</code></pre>

<p>至于conn.send如何发送数据，会在后面探讨。</p>

<p>现在我们可以探索 goroutine 如何读取客户端发送的 websocket 数据。这个 goroutine 的关键是读取 socket 数据，并将数据添加到 manager.boradcast 做进一步处理。</p>

<pre><code class="language-go">//$GOPATH/src/github.com/nraboy/realtime-chat/main.go
func (c *Client) read() {
    defer func() {
        manager.unregister &lt;- c
        c.socket.Close()
    }()
 
    for {
        _, message, err := c.socket.ReadMessage()
        if err != nil {
            manager.unregister &lt;- c
            c.socket.Close()
            break
        }
        jsonMessage, _ := json.Marshal(&amp;Message{Sender: c.id, Content: string(message)})
        manager.broadcast &lt;- jsonMessage
    }
}
</code></pre>

<p>如果读取 websocket 数据出错，可能意味着客户端已经断开连接。如果是这样，我们需要从服务器中注销这个客户端。</p>

<p>还记得前边的 conn.send 吗，它用来在第三个 goroutine 中写数据。</p>

<pre><code class="language-go">//$GOPATH/src/github.com/nraboy/realtime-chat/main.go
func (c *Client) write() {
    defer func() {
        c.socket.Close()
    }()
 
    for {
        select {
        case message, ok := &lt;-c.send:
            if !ok {
                c.socket.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }
 
            c.socket.WriteMessage(websocket.TextMessage, message)
        }
    }
}
</code></pre>

<p>如果 c.send channel有数据，我们将尝试发送这些数据。如果由于某些原因，channel 运行不正常，我们将向客户端发送断开连接的消息。</p>

<p>那么，如何启动这些 goroutine 呢，当我们启动服务器时，服务器 goroutine 将会启动，当有客户端连接时，其他 goroutine 将会启动。</p>

<p>main方法中的代码：</p>

<pre><code class="language-go">//$GOPATH/src/github.com/nraboy/realtime-chat/main.goGo
func main() {
    fmt.Println(&quot;Starting application...&quot;)
    go manager.start()
    http.HandleFunc(&quot;/ws&quot;, wsPage)
    http.ListenAndServe(&quot;:12345&quot;, nil)
}
</code></pre>

<p>我们在12345端口启动服务器，通过 websocket 连接访问。名为 wsPage 的方法如下所示：</p>

<pre><code class="language-go">//$GOPATH/src/github.com/nraboy/realtime-chat/main.goGo
func wsPage(res http.ResponseWriter, req *http.Request) {
    conn, error := (&amp;websocket.Upgrader{CheckOrigin: func(r *http.Request) bool { return true }}).Upgrade(res, req, nil)
    if error != nil {
        http.NotFound(res, req)
        return
    }
    client := &amp;Client{id: uuid.NewV4().String(), socket: conn, send: make(chan []byte)}
 
    manager.register &lt;- client
 
    go client.read()
    go client.write()
}
</code></pre>

<p>通过使用 websocket 包将HTTP请求升级到websocket请求。通过添加 CheckOrigin ，我们可以接受来自外部域的请求，从而消除跨域资源共享（CORS）的错误。</p>

<p>创建连接后，将创建一个客户端，并分配唯一的ID。如前所述，该客户端已经注册到服务器。客户端注册后，读写 goroutine 将被触发。</p>

<p>此时，我们可以通过如下命令启动应用。</p>

<pre><code class="language-shell">//Run Go Application
go run *.go
</code></pre>

<p>你不能在直接 web 浏览器中测试，但是可以建立一个 websocket 连接到 ws://localhost:12345/ws。</p>

<h4>创建Angular2 聊天客户端</h4>

<p>现在我们需要创建一个客户端的应用，客户端可以发送和接收消息。假设您已经安装了<a href="https://cli.angular.io/">Angular 2 CLI</a>，请执行以下操作：</p>

<pre><code class="language-shell">//Create New Angular 2 Project
ng new SocketExample
</code></pre>

<p>执行完将会生成一个单页应用，而我们想要完成的内容，是下方的动图演示的这样。</p>

<p><img src="/images/go/golang-angular2-chat.gif" alt="" /></p>

<p>补充：此处需cd SocketExmapl &amp;&amp; npm install。</p>

<p>JavaScript的 websocket 在Angular 2提供的一个类中。使用 Angular 2 CLI，通过执行如下操作创建provider。</p>

<pre><code class="language-shell">//Create Angular 2 Provider
ng g service socket
</code></pre>

<p>上述命令会在您的项目中创建 **src/app/socket.service.ts ** 和 <strong>src/app/socket.service.spec.ts</strong> 。spec文件用于单元测试，不在本文讨论范围内。打开 <strong>src/app/socket.service.ts</strong> 文件，编写以下 TypeScript 代码：</p>

<pre><code class="language-typescript">//src/app/socket.service.ts
import { Injectable, EventEmitter } from '@angular/core';
 
@Injectable()
export class SocketService {
 
    private socket: WebSocket;
    private listener: EventEmitter&lt;any&gt; = new EventEmitter();
 
    public constructor() {
        this.socket = new WebSocket(&quot;ws://localhost:12345/ws&quot;);
        this.socket.onopen = event =&gt; {
            this.listener.emit({&quot;type&quot;: &quot;open&quot;, &quot;data&quot;: event});
        }
        this.socket.onclose = event =&gt; {
            this.listener.emit({&quot;type&quot;: &quot;close&quot;, &quot;data&quot;: event});
        }
        this.socket.onmessage = event =&gt; {
            this.listener.emit({&quot;type&quot;: &quot;message&quot;, &quot;data&quot;: JSON.parse(event.data)});
        }
    }
 
    public send(data: string) {
        this.socket.send(data);
    }
 
    public close() {
        this.socket.close();
    }
 
    public getEventListener() {
        return this.listener;
    }
 
}
</code></pre>

<p>该提供者是可以注射的，并在触发某些事件事发送数据。在构造方法中，建立了与Go应用的WebSocket 连接，并创建了3个事件监听器。分别对应每个socket创建和销毁时，及接收到消息时。</p>

<p>send方法允许我们向Go应用发送消息，close方法用于通知Go应用我们将断开连接。</p>

<p>提供者程序已创建，但是还不能在我们的的应用程序的任何文件中使用。因此，我们需要将其添加到 <strong>src/app/app.module.ts</strong> 文件的 @NgModule 块中。打开文件并输入：</p>

<pre><code class="language-typescript">//src/app/app.module.ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpModule } from '@angular/http';
 
import { AppComponent } from './app.component';
import { SocketService } from &quot;./socket.service&quot;;
 
@NgModule({
    declarations: [
        AppComponent
    ],
    imports: [
        BrowserModule,
        FormsModule,
        HttpModule
    ],
    providers: [SocketService],
    bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>

<p>需要注意的是，此时我们已经将provider导入并且添加到 @NgModule 块的 providers数组中了。</p>

<p>现在我们可以专注处理页面的逻辑了。打开 <strong>src/app/app.component.ts</strong> 文件，并输入以下代码：</p>

<pre><code class="language-typescript">//src/app/app.component.ts
import { Component, OnInit, OnDestroy } from '@angular/core';
import { SocketService } from &quot;./socket.service&quot;;
 
@Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit, OnDestroy {
 
    public messages: Array&lt;any&gt;;
    public chatBox: string;
 
    public constructor(private socket: SocketService) {
        this.messages = [];
        this.chatBox = &quot;&quot;;
    }
 
    public ngOnInit() {
        this.socket.getEventListener().subscribe(event =&gt; {
            if(event.type == &quot;message&quot;) {
                let data = event.data.content;
                if(event.data.sender) {
                    data = event.data.sender + &quot;: &quot; + data;
                }
                this.messages.push(data);
            }
            if(event.type == &quot;close&quot;) {
                this.messages.push(&quot;/The socket connection has been closed&quot;);
            }
            if(event.type == &quot;open&quot;) {
                this.messages.push(&quot;/The socket connection has been established&quot;);
            }
        });
    }
 
    public ngOnDestroy() {
        this.socket.close();
    }
 
    public send() {
        if(this.chatBox) {
            this.socket.send(this.chatBox);
            this.chatBox = &quot;&quot;;
        }
    }
 
    public isSystemMessage(message: string) {
        return message.startsWith(&quot;/&quot;) ? &quot;&lt;strong&gt;&quot; + message.substring(1) + &quot;&lt;/strong&gt;&quot; : message;
    }
 
}
</code></pre>

<p>在上述 AppComponent类的构造方法中，我们注册服务提供者并初始化需要绑定到UI的变量。在构造函数中加载或订阅不太好，我们使用ngOninit方法来代替。</p>

<pre><code class="language-typescript">//src/app/app.component.ts
public ngOnInit() {
    this.socket.getEventListener().subscribe(event =&gt; {
        if(event.type == &quot;message&quot;) {
            let data = event.data.content;
            if(event.data.sender) {
                data = event.data.sender + &quot;: &quot; + data;
            }
            this.messages.push(data);
        }
        if(event.type == &quot;close&quot;) {
            this.messages.push(&quot;/The socket connection has been closed&quot;);
        }
        if(event.type == &quot;open&quot;) {
            this.messages.push(&quot;/The socket connection has been established&quot;);
        }
    });
}
</code></pre>

<p>在上述方法中，我们订阅了在provider中创建的事件监听器。在这里我们需要检查发生了什么事件。如果是一条消息，需要检查是否存在发件人，然后将其添加到消息中。</p>

<p>你可能注意到了，一些消息是以斜线开始的。用来表示系统消息，稍后会将其加粗。</p>

<p>当客户端断开时，关闭事件将会发送到服务器，如果消息已经发送，它也会被发送到服务器。</p>

<p>在查看HTML之前，先添加一些CSS，使其看起来更像一个聊天应用。打开 <strong>src/style.css</strong>，输入以下内容：</p>

<pre><code class="language-css">/*src/styles.css*/
/* You can add global styles to this file, and also import other style files */
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font: 13px Helvetica, Arial; }
form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
#messages { list-style-type: none; margin: 0; padding: 0; }
#messages li { padding: 5px 10px; }
#messages li:nth-child(odd) { background: #eee; }
</code></pre>

<p>现在，需要处理下HTML了。打开 <strong>src/app/app.component.html</strong> 文件，并输入以下内容：</p>

<pre><code class="language-html">&lt;!--src/app/app.component.html--&gt;
&lt;ul id=&quot;messages&quot;&gt;
    &lt;li *ngFor=&quot;let message of messages&quot;&gt;
        &lt;span [innerHTML]=&quot;isSystemMessage(message)&quot;&gt;&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;form action=&quot;&quot;&gt;
    &lt;input [(ngModel)]=&quot;chatBox&quot; [ngModelOptions]=&quot;{standalone: true}&quot; autocomplete=&quot;off&quot; /&gt;
    &lt;button (click)=&quot;send()&quot;&gt;Send&lt;/button&gt;
&lt;/form&gt;
</code></pre>

<p>这里我们只是简单的将消息数组遍历到屏幕上 。以斜线开头的消息将会被加粗。提交按钮绑定到了send方法中，当按下时，会提交输入框中的内容到Go应用。</p>

<h4>结语</h4>

<p>刚刚演示了如何使用 Go 和 Angular 2 创建一个 WebSocket 实时聊天应用。虽然没有在这个示例中存储聊天记录，但是这套逻辑可以应用于更复杂的项目，比如游戏，IOT，和其他很多场景。</p>

<h4>关于原作者</h4>

<p><a href="https://www.thepolyglotdeveloper.com/author/nraboy/">Nic Raboy</a>是现代网络和移动开发技术的倡导者。 他在Java，JavaScript，Golang以及各种框架（如Angular，NativeScript和Apache Cordova）方面拥有丰富的经验。 Nic写作的内容主要是他在使Web和移动开发更容易理解相关方面的经验。</p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://qichengzx.github.io/2017/07/15/create-real-time-chat-app-golang-angular-2-websockets.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="a73f5e067d643a87e5d36f7ae3799355" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://qichengzx.github.io/2017/07/02/HTTP2-Server-Push.html" class="article-date">
                      <time itemprop="datePublished">2017-07-02 00:09:13</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://qichengzx.github.io/2017/07/02/HTTP2-Server-Push.html">在Go中使用 HTTP/2 Server Push</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <h4>写在前面</h4>

<p>本文来自<a href="https://blog.golang.org/h2push">Golang的官方博客</a>，由 Jaana Burcu Dogan, Tom Bergan 发表于2017年3月24日。</p>

<p>近来看到此篇，觉得不错，非常适合用来学习Go中的 Server Push ，于是决定翻译一下，水平有限，如有不足不恰当的地方还请提出宝贵意见。</p>

<h4>序</h4>

<p>HTTP/2旨在解决HTTP/1.x的很多问题。现代网页通常包含很多资源：HTML，css，js，图片等等。在 HTTP/1.x 中，必须明确地请求这些资源。这是一个缓慢的过程。浏览器必须从获取HTML开始，然后在解析页面时获取更多资源。由于服务器必须等待浏览器发起请求，网络通常处于空闲，没有充分利用。</p>

<p>为了改善延迟，HTTP/2引入了 Server Push ，这允许服务器在明确的请求之前将资源推送到浏览器。服务器通常会知道一个页面所需要的额外的资源，并且可以在响应初始请求时开始推送这些资源。这就允许服务器充分利用空闲的网络来改善加载时间。</p>

<p><img src="/images/go/serverpush.svg" alt="server push示意" /></p>

<p>在协议层，HTTP/2 Server Push 由 PUSH_PROMISE 帧发起。PUSH_PROMISE 表明了服务器向客户端推送资源的意图。一旦浏览器接收到PUSH_PROMISE，它就会知道服务器会推送资源。如果浏览器后来发现需要这个资源，它会等待推送完成，而不是发起一个新的请求。这减少了浏览器在网络上等待的时间。</p>

<h4>net/http 包中的 Server Push</h4>

<p>Go1.8 引入了 http.Server 对 push 响应的支持，如果运行的服务器是 HTTP/2 服务器，并且请求连接使用了 HTTP/2，则可以使用此功能。在任何HTTP处理程序中，可以通过检查 http.ResponseWriter 是否实现了 http.Pusher 接口来判断是否支持 Server Push。</p>

<p>例如，如果服务器知道一个页面中包含 app.js，处理程序可以初始化一个 http.Pusher。</p>

<pre><code class="language-go">http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
  if push, ok := w.(http.Pusher); ok {
    //支持Push
    if err := pusher.Push(&quot;/app.js&quot;, nil); err != nil {
      log.Printf(&quot;Failed to push: %v&quot;, err)
    }
  }
  // ...
})
</code></pre>

<p>Push会为 app.js 创建一个 “合成请求”，将该请求合成到 PUSH_PROMISE 帧中，然后将请求转发到服务器的请求处理程序，请求处理程序会生成响应。Push的第二个参数指定了包含在 PUSH_PROMISE 中的附加header头，例如，如果对 app.js 的响应在 Accept-Encoding 上不同，则 PUSH_PROMISE 应包含 Accept-Encoding 的值。</p>

<pre><code class="language-go">http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
  if pusher, ok := w.(http.Pusher); ok {
    //支持Push
    options := &amp;http.PushOptions{
      Header: http.Header{
        &quot;Accept-Encoding&quot;: r.Header[&quot;Accept-Encoding&quot;],
      },
    }
    if err := pusher.Pusher(&quot;/app.js&quot;, options); err != nil {
      log.Printf(&quot;Failed to push: %v&quot;, err)
    }
  }
  // ...
})
</code></pre>

<p>完整示例见：</p>

<pre><code class="language-shell">$ go get golang.org/x/blog/content/h2push/server
</code></pre>

<p>启动服务，然后打开 <a href="https://localhost:8080">https://localhost:8080</a>，浏览器开发工具应该会显示服务器推送了 app.js 和 style.css 。</p>

<p><img src="/images/go/networktimeline.png" alt="网络请求耗时" /></p>

<h4>在响应前开始Push</h4>

<p>在发送响应之前调用Push是个好主意，否则可能会意外产生重复的响应，例如，假设下边是HTML响应的一部分：</p>

<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
	&lt;link rel=&quot;stylesheet&quot; href=&quot;a.cs&quot;&gt;...	
</code></pre>

<p>然后调用 Push(&ldquo;a.css&rdquo;, nil) ，浏览器可能会在接收到 PUSH_PROMISE 之前就开始解析这段 HTM L了，这种情况下，浏览器除了接收到 PUSH_PROMISE 之外，还会发起一个 a.css 的请求，那么服务器就会为 a.css 生成两个请求。而在写入响应之前调用PUSH则避免了这种可能性。</p>

<h4>何时使用Server Push</h4>

<p>应该考虑在任何网络连接空闲时使用 Server Push 。刚完成为 web app 发送 HTML ？不要浪费时间等待请求，开始推送客户端需要用到的资源，你有没有过将资源嵌入到 HTML 文件中以减少延迟？替换掉内联，尝试使用推送。重定向是另一个使用推送的好时机，因为客户端在这个过程中几乎把时间全浪费在请求的往返上。有很多情况适合使用 Push ，我们才刚刚开始。</p>

<p>如果没有提到以下几个注意事项，将是我们的失职。</p>

<p>​   首先，只能推送当前服务器上的资源-这意味着无法推送托管在第三方服务器或CDN上的资源。</p>

<p>​   第二，除非能确定客户端确实需要，否则不要推送，这样会浪费带宽。当浏览器已经缓存了某些资源时， 必须要避免推送。</p>

<p>​   第三，天真的把所有资源推送到页面会使性能更糟糕。</p>

<p>以下链接可以作为补充阅读：</p>

<ul>
<li><a href="https://calendar.perfplanet.com/2016/http2-push-the-details/">HTTP/2 Push: The Details</a></li>
<li><a href="https://www.igvita.com/2013/06/12/innovating-with-http-2.0-server-push/">Innovating with HTTP/2 Server Push</a></li>
<li><a href="https://github.com/h2o/h2o/issues/421">Cache-Aware Server Push in H2O</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/">The PRPL Pattern</a></li>
<li><a href="https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0">Rules of Thumb for HTTP/2 Push</a></li>
<li><a href="https://tools.ietf.org/html/rfc7540#section-8.2">Server Push in the HTTP/2 spec</a></li>
</ul>

<h4>结尾</h4>

<p>Go1.8 标准库为 HTTP/2 Server Push 提供了开箱即用的支持，为优化 Web 应用程序提供更多灵活性。</p>

<p>转到<a href="https://http2.golang.org/serverpush">HTTP/2 Server Push演示页面</a>查看实际效果。</p>

<h4>一些资料</h4>

<p><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn">HTTP/2 简介</a></p>

<p>HTTP/2 Server Push 详解：</p>

<p>原文：</p>

<p><a href="https://www.smashingmagazine.com/2017/04/guide-http2-server-push/">A Comprehensive Guide To HTTP/2 Server Push</a></p>

<p>译文：</p>

<p><a href="http://www.alloyteam.com/2017/04/guide-http2-server-push-part1/">HTTP/2 Server Push 详解（上）</a></p>

<p><a href="http://www.alloyteam.com/2017/04/guide-http2-server-push-part2/">HTTP/2 Server Push 详解（下）</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://qichengzx.github.io/2017/07/02/HTTP2-Server-Push.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="543d34e1e7ac1a0d309eb2356850f2e1" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://qichengzx.github.io/2017/06/27/order-by-distance-in-mysql.html" class="article-date">
                      <time itemprop="datePublished">2017-06-27 22:18:19</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/mysql">mysql</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://qichengzx.github.io/2017/06/27/order-by-distance-in-mysql.html">MySQL实现按经纬度做距离排序</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p><img src="/images/geolocation.png" alt="" />
题图来自网络</p>

<p>工作中某些业务需要用到按距离排序返回结果，之前的方式是根据前端传过来来的经纬度，和指定范围的距离，算出一个坐标区间，再用这个区间的值去MySQL中查找，类似“where lat between (lat1, lat2) and lng between (lng1,lng2)”，查出数据后，再遍历数据计算每一条数据到这个经纬度的距离，然后根据得出的距离排序返回。低效，麻烦，不方便分页。</p>

<p>于是决定直接从MySQL中算出距离后返回，省事，方便，还可以直接分页了。</p>

<p>查资料后发现还挺简单的，下方的示例是从<a href="https://developers.google.com/maps/articles/phpsqlsearch_v3">Google官方的文档</a>中摘取出来。</p>

<p>创建如下数据表：</p>

<pre><code class="language-mysql">CREATE TABLE `markers` (
  `id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY ,
  `name` VARCHAR( 60 ) NOT NULL ,
  `address` VARCHAR( 80 ) NOT NULL ,
  `lat` FLOAT( 10, 6 ) NOT NULL ,
  `lng` FLOAT( 10, 6 ) NOT NULL
) ENGINE = MYISAM ;
</code></pre>

<p>填充数据：</p>

<pre><code class="language-mysql">INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Frankie Johnnie &amp; Luigo Too','939 W El Camino Real, Mountain View, CA','37.386339','-122.085823');
INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Amici\'s East Coast Pizzeria','790 Castro St, Mountain View, CA','37.38714','-122.083235');
INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Kapp\'s Pizza Bar &amp; Grill','191 Castro St, Mountain View, CA','37.393885','-122.078916');
INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Round Table Pizza: Mountain View','570 N Shoreline Blvd, Mountain View, CA','37.402653','-122.079354');
INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Tony &amp; Alba\'s Pizza &amp; Pasta','619 Escuela Ave, Mountain View, CA','37.394011','-122.095528');
INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Oregano\'s Wood-Fired Pizza','4546 El Camino Real, Los Altos, CA','37.401724','-122.114646');
</code></pre>

<p>下面，开始从表中查询数据。</p>

<p>根据latitude，longitude值，基于<a href="http://en.wikipedia.org/wiki/Haversine_formula">Haversine公式</a>从表中查询数据。</p>

<p>假设我们要查询latitude=37.38714,longitude=-122.083235，范围在25英里内的前20条数据，可以这样：</p>

<pre><code class="language-mysql">SELECT id, ( 3959 * acos( cos( radians('37.38714') ) * cos( radians( lat ) ) * cos( radians( lng ) - radians('-122.083235') ) + sin( radians('37.38714') ) * sin( radians( lat ) ) ) ) AS distance FROM markers HAVING distance &lt; 25 ORDER BY distance LIMIT 0, 20;
</code></pre>

<p>如果想使用“公里”代替“英里”，将3959换成6371即可。</p>

<p>特别简单。</p>

<p>参考资料：</p>

<p><a href="https://developers.google.com/maps/articles/phpsqlsearch_v3">Creating a Store Locator with PHP, MySQL &amp; Google Maps</a></p>

<p><a href="https://zh.scribd.com/presentation/2569355/Geo-Distance-Search-with-MySQL">Geo/Spatial Search with MySQL</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://qichengzx.github.io/2017/06/27/order-by-distance-in-mysql.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/mysql">mysql</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="740de747745d69cb2c6d653b81f1ce05" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://qichengzx.github.io/2017/03/06/insert-filter-in-beego.html" class="article-date">
                      <time itemprop="datePublished">2017-03-06 08:23:47</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://qichengzx.github.io/2017/03/06/insert-filter-in-beego.html">Beego中使用过滤器</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p>为了方便调试和排错，决定在现有的beego程序里加上requestID。</p>

<p>查了些资料发现写的并不是特别清楚和详细，在此总结一下，也算是加深下印象。</p>

<p>astaxie说可以用过滤器实现，就是在Beego运行时在特定的步骤前加入。而由于我的需求比较简单，就选在了BeforeRouter。</p>

<p>在main.go中:</p>

<pre><code class="language-Go">import &quot;github.com/astaxie/beego/context&quot;
import &quot;github.com/satori/go.uuid&quot;

</code></pre>

<p>在main函数中加入:</p>

<pre><code class="language-Go">var FilterRequestID = func(ctx *context.Context) {
	requestId := uuid.NewV4().String()
	ctx.Input.SetData(&quot;requestId&quot;, requestId)
}

beego.InsertFilter(&quot;/*&quot;, beego.BeforeRouter, FilterRequestID)

</code></pre>

<p>在需要使用的地方，如</p>

<pre><code class="language-Go">// @router /requestid [get]
func (this *MyController) Requestid() {
	//读取requestId
	rid := this.Ctx.Input.GetData(&quot;requestId&quot;).(string)

	fmt.Println(&quot;requestId:&quot;,rid)
}
</code></pre>

<p>或者</p>

<pre><code class="language-Go">func (m *MyController) Requestid() {
	rid := m.Ctx.Input.GetData(&quot;requestId&quot;).(string)

	fmt.Println(&quot;requestId:&quot;,rid)
}
</code></pre>

<p>其实很简单，但是文档和查到的资料中都没有明确的说需要引用 &ldquo;github.com/astaxie/beego/context&rdquo;，导致写的时候浪费了一些时间。</p>

<p>参考资料:</p>

<p><a href="https://beego.me/docs/mvc/controller/filter.md">过滤器</a>
<a href="https://gocn.io/article/95">beego log中增加request id的一种方式</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://qichengzx.github.io/2017/03/06/insert-filter-in-beego.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="5ec75bc5e5f69005cf2ff1c8c4141d18" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://qichengzx.github.io/2016/12/27/shortlen-url-by-go.html" class="article-date">
                      <time itemprop="datePublished">2016-12-27 21:27:34</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://qichengzx.github.io/2016/12/27/shortlen-url-by-go.html">Go语言写的一个短网址服务</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p><img src="/images/go/best-url-shortener-to-make-earn-money.png" alt="" />
<center>题图来自<a href="http://www.dwtricks.com/2015/05/best-10-url-shortener-networks-to-earn-money-2015.html/">http://www.dwtricks.com/</a></center></p>

<p>&ldquo;缩址，又称短址、短网址、网址缩短、缩短网址、URL缩短等，指的是一种互联网上的技术与服务。此服务可以提供一个非常短小的URL以代替原来的可能较长的URL，将长的URL地址缩短。
用户访问缩短后的URL时，通常将会重定向到原来的URL。&rdquo;</p>

<p>&ndash; Wikipedia</p>

<p>虽然短网址早已不再那么受广泛关注。但是不妨拿来练手。</p>

<p>根据公开可以搜索到的资料，短网址一般是将一个ID转换到一串字母，生成短的网址用于传播，实际访问会重定向到原网址。如上所述。</p>

<p>那么使用Go来写这个有什么优势呢，优势之一当然是，Go部署简单，只需要copy执行文件即可。执行速度也快，甚至连HTTP服务器都不需要。</p>

<h5>下边就边写边说明。</h5>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;time&quot;
	&quot;net/http&quot;
	&quot;database/sql&quot;

	&quot;github.com/gin-gonic/gin&quot;

	&quot;github.com/garyburd/redigo/redis&quot;
	_ &quot;github.com/go-sql-driver/mysql&quot;

	&quot;github.com/speps/go-hashids&quot;
)
</code></pre>

<h6>定义hashid包需要的salt，即生成字符串的最短位数。</h6>

<pre><code class="language-go">const (
	hdSalt        = &quot;mysalt&quot;
	hdMinLength   = 5
	defaultDomain = &quot;http://localhost:8000/&quot;
)
</code></pre>

<h6>定义redis和MySQL的配置信息</h6>

<pre><code class="language-go">var (
	RedisClient *redis.Pool
	RedisHost   = &quot;127.0.0.1:6379&quot;
	RedisDb     = 0
	RedisPwd    = &quot;&quot;

	db      *sql.DB
	DB_HOST = &quot;tcp(127.0.0.1:3306)&quot;
	DB_NAME = &quot;short&quot;
	DB_USER = &quot;root&quot;
	DB_PASS = &quot;&quot;
)
</code></pre>

<h5>main函数，首先连接redis和MySQL。定义如下路由：</h5>

<ul>
<li>访问首页</li>
<li>访问hash</li>
<li>访问短网址信息页</li>
<li>生成短网址接口</li>
</ul>

<p>熟悉的朋友应该都知道，访问短网址服务的首页一般会跳转到一个固定的网址，比如渣浪微博会跳转到微博首页，Twitter则是给出“Twitter uses the t.co domain as part of a service to protect users from harmful activity”的提示。这里我们也让它跳转到一个指定的网页。</p>

<p>最后，以8080端口运行，实际线上会使用80端口，可以自行修改。</p>

<pre><code class="language-go">func main() {
	initRedis()
	initMysql()

	gin.SetMode(gin.DebugMode)
	r := gin.Default()

	r.GET(&quot;/&quot;, func(c *gin.Context) {
		//http code can be StatusFound or StatusMovedPermanently 
		c.Redirect(http.StatusFound, defaultDomain)
	})
	r.GET(&quot;/:hash&quot;, expandUrl)
	r.GET(&quot;/:hash/info&quot;, expandUrlApi)
	r.POST(&quot;/short&quot;, shortUrl)

	r.Run(&quot;:8000&quot;)
}
</code></pre>

<h5>连接redis和MySQL</h5>

<pre><code class="language-go">func initRedis() {
	// 建立连接池
	RedisClient = &amp;redis.Pool{
		MaxIdle:     1,
		MaxActive:   10,
		IdleTimeout: 180 * time.Second,
		Dial: func() (redis.Conn, error) {
			c, err := redis.Dial(&quot;tcp&quot;, RedisHost)
			if err != nil {
				return nil, err
			}
			if _, err := c.Do(&quot;AUTH&quot;, RedisPwd); err != nil {
				c.Close()
				return nil, err
			}
			c.Do(&quot;SELECT&quot;, RedisDb)
			return c, nil
		},
	}
}

func initMysql() {
	dsn := DB_USER + &quot;:&quot; + DB_PASS + &quot;@&quot; + DB_HOST + &quot;/&quot; + DB_NAME + &quot;?charset=utf8&quot;
	db, _ = sql.Open(&quot;mysql&quot;, dsn)
	db.SetMaxOpenConns(5)
	db.SetMaxIdleConns(20)
	db.Ping()
}
</code></pre>

<h5>生成短网址的接口函数。</h5>

<p>根据传入的URL参数，进行简单的验证后，写入数据库。根据写入后生成的ID，再生成一个字符串，然后返回给调用方。</p>

<pre><code class="language-go">func shortUrl(c *gin.Context) {
	longUrl := c.PostForm(&quot;url&quot;)

	if longUrl == &quot;&quot; {
		c.JSON(200, gin.H{
			&quot;status&quot;:  500,
			&quot;message&quot;: &quot;请传入网址&quot;,
		})
		return
	}

	if !strings.HasPrefix(longUrl, &quot;http&quot;) {
		longUrl = &quot;http://&quot; + longUrl
	}

	if hash, ok := insert(longUrl); ok {
		c.JSON(200, gin.H{
			&quot;status&quot;:  200,
			&quot;message&quot;: &quot;ok&quot;,
			&quot;short&quot;:   defaultDomain + hash,
		})
	}
}
</code></pre>

<h5>根据HASH解析并跳转到对应的长URL，不存在则跳转到默认地址</h5>

<pre><code class="language-go">func expandUrl(c *gin.Context) {
	hash := c.Param(&quot;hash&quot;)

	if url, ok := findByHash(hash); ok {
		c.Redirect(http.StatusMovedPermanently, url)
	}
	// 注意:
	// 	实际中，此应用的运行域名可能与默认域名不同，如a.com运行此程序，默认域名为b.com
	// 	当访问一个不存在的HASH或a.com时，可以跳转到任意域名，即defaultDomain
	c.Redirect(http.StatusMovedPermanently, defaultDomain)
}
</code></pre>

<h5>根据HASH在redis中查找并返回结果，不存在则返回404状态</h5>

<pre><code class="language-go">func expandUrlApi(c *gin.Context) {
	hash := c.Param(&quot;hash&quot;)

	if url, ok := findByHash(hash); ok {
		c.JSON(200, gin.H{
			&quot;status&quot;:  200,
			&quot;message&quot;: &quot;ok&quot;,
			&quot;data&quot;:    url,
		})
		return
	}

	// 此处可以尝试在MySQL中再次查询
	c.JSON(200, gin.H{
		&quot;status&quot;:  404,
		&quot;message&quot;: &quot;url of hash is not exist&quot;,
	})
}
</code></pre>

<h5>将ID转换成对应的HASH值，hdSalt与hdMinLength 会影响生成结果，确定后不要改动</h5>

<pre><code class="language-go">func shortenURL(id int) string {
	hd := hashids.NewData()
	hd.Salt = hdSalt
	hd.MinLength = hdMinLength

	h := hashids.NewWithData(hd)
	e, _ := h.Encode([]int{id})

	return e
}
</code></pre>

<h5>根据HASH解析出对应的ID值, hdSalt与hdMinLength 会影响生成结果，确定后不要改动</h5>

<pre><code class="language-go">func expand(hash string) int {
	hd := hashids.NewData()
	hd.Salt = hdSalt
	hd.MinLength = hdMinLength

	h := hashids.NewWithData(hd)
	d, _ := h.DecodeWithError(hash)

	return d[0]
}
</code></pre>

<h5>数据库中根据ID查找</h5>

<pre><code class="language-go">func find(id int) (string, bool) {
	var url string
	err := db.QueryRow(&quot;SELECT url FROM url WHERE id = ?&quot;, id).Scan(&amp;url)
	if err == nil {
		return url, true
	} else {
		return &quot;&quot;, false
	}
}
</code></pre>

<h5>在redis中根据HASH查找</h5>

<pre><code class="language-go">func findByHash(h string) (string, bool) {
	rc := RedisClient.Get()

	defer rc.Close()
	url, _ := redis.String(rc.Do(&quot;GET&quot;, &quot;URL:&quot;+h))

	if url != &quot;&quot; {
		return url, true
	}

	id := expand(h)
	if urldb, ok := find(id); ok {
		return urldb, true
	}

	return &quot;&quot;, false
}
</code></pre>

<h5>将长网址插入到数据库中，并把返回的ID生成HASH和长网址存入redis</h5>

<pre><code class="language-go">func insert(url string) (string, bool) {
	stmt, _ := db.Prepare(`INSERT INTO url (url) values (?)`)
	res, err := stmt.Exec(url)
	checkErr(err)

	id, _ := res.LastInsertId()

	rc := RedisClient.Get()
	defer rc.Close()

	hash := shortenURL(int(id))
	rc.Do(&quot;SET&quot;, &quot;URL:&quot;+hash, url)

	return hash, true
}
</code></pre>

<h4>打印方法，和检查错误的方法</h4>

<pre><code class="language-go">func Log(v ...interface{}) {
	fmt.Println(v...)
}

func checkErr(err error) {
	if err != nil {
		panic(err)
	}
}
</code></pre>

<p>有些地方还需修改，就算是抛砖引玉吧。</p>

<p>感谢<a href="http://hashids.org/">hashids</a></p>

<h4>Github地址 ： <a href="https://github.com/qichengzx/shortme">shortme</a></h4>

<p>相关资料：</p>

<p><a href="http://mashable.com/2008/01/08/url-shortening-services/#CgEzOrfnzPqb">URL Toolbox: 90+ URL Shortening Services</a>
<a href="http://tinyurl.com/">TinyURL</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://qichengzx.github.io/2016/12/27/shortlen-url-by-go.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/%e7%9f%ad%e7%bd%91%e5%9d%80">短网址</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="a613e354bbefc581f5bedca0a0968c2d" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://qichengzx.github.io/2016/12/14/toutiao-images-spider-by-golang.html" class="article-date">
                      <time itemprop="datePublished">2016-12-14 16:28:36</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://qichengzx.github.io/2016/12/14/toutiao-images-spider-by-golang.html">Go 福利小爬虫 爬取今日头条美女图</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p><img src="/images/go/toutiao.gif" alt="" /></p>

<p>写完爬取糗百热门后没几天，又开始写了爬取今日头条图片的<a href="https://github.com/qichengzx/toutiaoSpider">工具</a>。</p>

<p>灵感来源于<a href="http://www.jianshu.com/p/d67b1d4b99ad">Python 福利小爬虫，爬取今日头条街拍美女图</a>，作者很详细的分析了今日头条一个搜索接口，并列出了步骤。</p>

<p>而我用Go写的，稍稍做了改动，加入了可以自定义爬取标签的功能，并在写本文前完成了以 &ldquo;标签/文章名/图片名&rdquo; 结构存储图片的功能。</p>

<p>分析网页依然使用<a href="https://github.com/PuerkitoBio/goquery">goquery</a>。</p>

<h3>分析接口返回结构</h3>

<pre><code class="language-json">{
	&quot;count&quot;: 30,
	&quot;action_label&quot;: &quot;click_search&quot;,
	&quot;return_count&quot;: 0,
	&quot;has_more&quot;: 0,
	&quot;page_id&quot;: &quot;/search/&quot;,
	&quot;cur_tab&quot;: 1,
	&quot;offset&quot;: 150,
	&quot;action_label_web&quot;: &quot;click_search&quot;,
	&quot;show_tabs&quot;: 1,
	&quot;data&quot;: [
		{
			&quot;play_effective_count&quot;: &quot;6412&quot;,
			&quot;media_name&quot;: &quot;开物志&quot;,
			&quot;repin_count&quot;: 49,
			&quot;ban_comment&quot;: 0,
			&quot;show_play_effective_count&quot;: 1,
			&quot;abstract&quot;: &quot;&quot;,
			&quot;display_title&quot;: &quot;&quot;,
			&quot;datetime&quot;: &quot;2016-12-13 21:35&quot;,
			&quot;article_type&quot;: 0,
			&quot;more_mode&quot;: false,
			&quot;create_time&quot;: 1481636117,
			&quot;has_m3u8_video&quot;: 0,
			&quot;keywords&quot;: &quot;&quot;,
			&quot;video_duration&quot;: 161,
			&quot;has_mp4_video&quot;: 0,
			&quot;favorite_count&quot;: 49,
			&quot;aggr_type&quot;: 0,
			&quot;article_sub_type&quot;: 0,
			&quot;bury_count&quot;: 2,
			&quot;title&quot;: &quot;沃尔沃Tier 4 Final大型引擎的工作原理揭秘&quot;,
			&quot;has_video&quot;: true,
			&quot;share_url&quot;: &quot;http://toutiao.com/group/6363577276176531969/?iid=0&amp;app=news_article&quot;,
			&quot;id&quot;: 6363577276176532000,
			&quot;source&quot;: &quot;开物志&quot;,
			&quot;comment_count&quot;: 4,
			&quot;article_url&quot;: &quot;http://toutiao.com/group/6363577276176531969/&quot;,
			&quot;image_url&quot;: &quot;http://p3.pstatp.com/list/12f0000909de79ceeabc&quot;,
			&quot;middle_mode&quot;: true,
			&quot;large_mode&quot;: false,
			&quot;item_source_url&quot;: &quot;/group/6363577276176531969/&quot;,
			&quot;media_url&quot;: &quot;http://toutiao.com/m6643043415/&quot;,
			&quot;display_time&quot;: 1481635793,
			&quot;publish_time&quot;: 1481635793,
			&quot;go_detail_count&quot;: 2290,
			&quot;image_list&quot;: [],
			&quot;item_seo_url&quot;: &quot;/group/6363577276176531969/&quot;,
			&quot;video_duration_str&quot;: &quot;02:41&quot;,
			&quot;source_url&quot;: &quot;/group/6363577276176531969/&quot;,
			&quot;tag_id&quot;: 6363577276176532000,
			&quot;natant_level&quot;: 0,
			&quot;seo_url&quot;: &quot;/group/6363577276176531969/&quot;,
			&quot;display_url&quot;: &quot;http://toutiao.com/group/6363577276176531969/&quot;,
			&quot;url&quot;: &quot;http://toutiao.com/group/6363577276176531969/&quot;,
			&quot;level&quot;: 0,
			&quot;digg_count&quot;: 4,
			&quot;behot_time&quot;: 1481635793,
			&quot;tag&quot;: &quot;news_car&quot;,
			&quot;has_gallery&quot;: false,
			&quot;has_image&quot;: false,
			&quot;highlight&quot;: {
			&quot;source&quot;: [],
			&quot;abstract&quot;: [],
			&quot;title&quot;: []
			},
			&quot;group_id&quot;: 6363577276176532000,
			&quot;middle_image&quot;: &quot;http://p3.pstatp.com/list/12f0000909de79ceeabc&quot;
		},
	],
	&quot;message&quot;: &quot;success&quot;,
	&quot;action_label_pgc&quot;: &quot;click_search&quot;
}
</code></pre>

<p>嗯，特别多，其实只需要 data 里的内容就可以了。</p>

<p>所以</p>

<h4>构造一个请求结果的struct。</h4>

<pre><code class="language-go">type ApiData struct {
	Has_more int    `json:&quot;has_more&quot;`
	Data     []Data `json:&quot;data&quot;`
}
</code></pre>

<p>再看下data里，嗯，没用的又一大堆。</p>

<h4>只需要文章链接就够了。</h4>

<pre><code class="language-go">type Data struct {
	Article_url string `json:&quot;article_url&quot;`
}
</code></pre>

<p>有了文章链接，那就好说了，啥都好商量。</p>

<h4>分析文章结构</h4>

<p>id=&ldquo;J_content&rdquo; 下是文章的主要内容，class=&ldquo;article-title&rdquo;是文章标题，class=&ldquo;article-content&rdquo;里是文章内容，只需要article-content里所有img元素就可以了。</p>

<pre><code class="language-go">type Img struct {
	Src string `json:&quot;src&quot;`
}
</code></pre>

<p>由于需要一直更改查询接口的offset参数，所以直接把接口地址拿到外边做了全局变量。并且默认存在下一页。tag用来表示当前爬取的标签的名称。</p>

<pre><code class="language-go">var (
	host    string = &quot;http://www.toutiao.com/search_content/?format=json&amp;keyword=%s&amp;count=30&amp;offset=%d&quot;
	hasmore bool   = true
	tag     string
)
</code></pre>

<h3>正菜</h3>

<h4>0. 接收参数</h4>

<p>首先，接收并遍历命令行中传入的标签。</p>

<pre><code class="language-go">func main() {
	for _, tag = range os.Args[1:] {
		hasmore = true
		getByTag()
	}
	log.Println(&quot;全部抓取完毕&quot;)
}
</code></pre>

<p>每个循环开始时重置 hasmore 。</p>

<h4>1. 循环请求接口</h4>

<pre><code class="language-go">func getByTag() {
	i, offset := 1, 0
	for {
		if hasmore {
			log.Printf(&quot;标签: '%s'，第 '%d' 页, OFFSET: '%d' \n&quot;, tag, i, offset)
			tmpUrl := fmt.Sprintf(host, tag, offset)
			getResFromApi(tmpUrl)
			offset += 30
			i++

			time.Sleep(500 * time.Millisecond)
		} else {
			break
		}
	}
	log.Printf(&quot;标签: '%s', 共 %v 页，爬取完毕\n&quot;, tag, i-1)
}
</code></pre>

<p>重置当前页，和当前offset。页数从第一页开始，主要是显示进度看起来更人性化一些。但是程序员的世界是从0开始。。。想改成0就改成0吧。</p>

<p>hasmore = true 表示存在下一页，使用fmt包的Sprintf方法格式化请求链接。然后对offset+30，对当前页i+1。再之后停顿了500毫秒。</p>

<p>这里其实有个问题，如果实际内容以每页30请求，可能恰好有150条，即每页数量的整数倍，但是这个时候接口返回的has_more依然等于1，即服务端认为还有下一页。。。但是其实没有了，所以会有一次空循环。</p>

<h4>2. 处理请求结果</h4>

<pre><code class="language-go">func getResFromApi(url string) {
	resp, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}

	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		log.Fatal(err)
	}

	var res ApiData
	json.Unmarshal([]byte(string(body)), &amp;res)

	for _, item := range res.Data {
		getImgByPage(item.Article_url)
	}

	if res.Has_more == 0 {
		hasmore = false
	}
}
</code></pre>

<p>没啥说的，拿到每一个请求接口的链接后打开，把结果数组中的data解析到ApiData中，于是就拿到了文章链接，然后遍历处理。</p>

<p>遍历完后要看下has_more的值，如果为0表示没有下一页了，修改全局变量hasmore的值，结束最外层的循环。</p>

<h4>3. 处理文章</h4>

<pre><code class="language-go">func getImgByPage(url string) {
	//部分请求结果中包含其他网站的链接，会导致下面的query出现问题
	if strings.Contains(url, &quot;toutiao.com&quot;) {
		doc, err := goquery.NewDocument(url)
		if err != nil {
			log.Fatal(err)
		}

		title := doc.Find(&quot;#article-main .article-title&quot;).Text()
		title = strings.Replace(title, &quot;/&quot;, &quot;&quot;, -1)
		os.MkdirAll(tag+&quot;/&quot;+title, 0777)

		doc.Find(&quot;#J_content .article-content img&quot;).Each(func(i int, s *goquery.Selection) {
			src, _ := s.Attr(&quot;src&quot;)
			log.Println(title, src)
			getImgAndSave(src, title)
		})
	}
}

</code></pre>

<p>最外层加了判断，是因为有一部分结果的链接是其他网站的。。。。</p>

<p>虽然这个判断很low，但是也够用了。</p>

<p>然后终于该用上goquery了，拿到标题，然后遍历文章内容中的img标签，就拿到了每一篇文章的每一张图片。</p>

<h4>4. 保存图片</h4>

<p>在上一步把图片地址和文章名称传递给了getImgAndSave。</p>

<pre><code class="language-go">func getImgAndSave(url string, dirname string) {
	path := strings.Split(url, &quot;/&quot;)
	var name string
	if len(path) &gt; 1 {
		name = path[len(path)-1]
	}

	resp, err := http.Get(url)
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Fatal(&quot;请求失败&quot;, err)
		return
	}

	contents, err := ioutil.ReadAll(resp.Body)
	defer func() {
		if x := recover(); x != nil {
			return
		}
	}()
	err = ioutil.WriteFile(&quot;./&quot;+tag+&quot;/&quot;+dirname+&quot;/&quot;+name+&quot;.jpg&quot;, contents, 0644)
	if err != nil {
		log.Fatal(&quot;写入文件失败&quot;, err)
	}
}
</code></pre>

<p>先分割图片链接，把最后一个&rdquo;/&ldquo;后的内容当成文件名。</p>

<p>后边get图片内容，但是有时候会出现对方服务器出错的情况，http状态码为500，所以加了判断请求是否成功的判断。</p>

<p>然后就是读取内容，保存到文件中了。</p>

<p>这里使用了WriteFile方式，查资料的时候还看到有闲Create文件，然后io.Copy写入的。</p>

<h4>到这里就结束了。</h4>

<h3>RUN</h3>

<pre><code>go run main.go 美女 模特
</code></pre>

<p>等着看图吧。</p>

<p>github地址：<a href="https://github.com/qichengzx/toutiaoSpider">toutiaoSpider</a>，欢迎star。</p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://qichengzx.github.io/2016/12/14/toutiao-images-spider-by-golang.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/%e4%bb%8a%e6%97%a5%e5%a4%b4%e6%9d%a1">今日头条</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/goquery">goquery</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="c3944b0882070ad3a784fa6fc304b7af" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://qichengzx.github.io/2016/12/04/go-qiubai.html" class="article-date">
                      <time itemprop="datePublished">2016-12-04 15:49:04</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://qichengzx.github.io/2016/12/04/go-qiubai.html">Go语言写爬取糗百热门帖子</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p>闲来无事，想着也用Go来写个爬虫之类的东西，我并不知道这算不算严格意义上的爬虫。</p>

<p>思前想后，觉得写个爬糗百热门的脚本吧，一来足够简单，二来大概熟悉下流程。</p>

<p>首先，选了<a href="https://github.com/PuerkitoBio/goquery">goquery</a>这个包来解析HTML，声称与jquery相似的用法，事实上也确实是这样，非常方便。</p>

<p>定个目标，只爬取列表页的帖子内容，作者和回帖都不管。</p>

<pre><code>package main

import (
	&quot;github.com/PuerkitoBio/goquery&quot;
	&quot;log&quot;
)

//定义结构体
type Qb struct {
	Id int `json:&quot;id&quot;`
	Content string `json:&quot;content&quot;`
}

func main() {
	var url = &quot;http://www.qiushibaike.com/hot&quot;

	doc, err := goquery.NewDocument(url)
	if err != nil {
		log.Fatal(err)
	}

	var qb []Qb
	doc.Find(&quot;#content-left .article&quot;).Each(func(i int, s *goquery.Selection) {
		//s即为当前的 .article 元素，查找下级中的span元素的内容。
		content := s.Find(&quot;.content span&quot;).Text()
		qb = append(qb, Qb{Id: i, Content: content})
	})

	log.Println(qb)
}
</code></pre>

<p>&rdquo;#content-left .article&rdquo; 即每一条帖子作为元素的class。</p>

<p>将会输出：</p>

<pre><code>[
	{0 结婚十三周年那天，老婆望着一大桌子菜不禁泪流满面。我帮她拭去泪水:瞧你，都激动的哭了!老婆却说:我激动个屁!想想这十三年跟着你受的罪，我实在忍不住啊!} 
	{1 前几天天冷，就给妹妹买了条围巾，然后她说谢谢哥，本人本着组织精神说你应该谢谢你嫂子，她惊讶的对我说:哥，你谈女朋友了。我说:没有，你应该感谢她一直到现在都没出现，哥才有钱给你买东西} 
	{2 跟哥们去理发，剪头的是个妹纸。。妹纸:“你有女朋友么？”哥们一听，突然兴奋的说:“没有！”妹纸:“我是个实习生，本来想给你换大工的，看你没有女朋友，我就随意剪了！”哥们你别看我，我就是一口水没忍住，喷你脸上了而已！} 
	{3 老妈比较胖，小时候每次打我我都是撒腿就跑，老妈没一次抓到我的。直到老妈学会骑自行车以后，那鞭子挥得………真像套马杆的汉子，威武雄壮……}
]
</code></pre>

<p>那么如何展示到页面中呢。</p>

<p>我选择了 <a href="https://github.com/gin-gonic/gin">gin</a> 框架。</p>

<p>修改一下代码。</p>

<pre><code>func main() {
	r := gin.Default()
	r.LoadHTMLGlob(&quot;public/*&quot;)
	r.GET(&quot;/&quot;, Index)
	r.Run()
}

func Index(c *gin.Context) {
	var url = &quot;http://www.qiushibaike.com/hot&quot;

	doc, err := goquery.NewDocument(url)
	if err != nil {
		log.Fatal(err)
	}

	var result []Qb
	doc.Find(&quot;#content-left .article&quot;).Each(func(i int, s *goquery.Selection) {
		content := s.Find(&quot;.content span&quot;).Text()
		result = append(result, Qb{Id: i, Content: content})
	})

	c.HTML(http.StatusOK, &quot;index.html&quot;, gin.H{
		&quot;items&quot;: result,
		&quot;title&quot;: &quot;糗百热门&quot;
	})
}
</code></pre>

<p>可以看到，</p>

<pre><code>r := gin.Default()
r.LoadHTMLGlob(&quot;public/*&quot;)
r.GET(&quot;/&quot;, Index)
</code></pre>

<p>这里加载了public目录中的模板，然后下一行，表示，接收到 &ldquo;/&rdquo; 的请求时，调用Index方法去处理。</p>

<p>到这里，文档的抓取，解析，构造数据就已经完成，下一步，看一下怎么显示到页面中。</p>

<pre><code>{% raw %}
&lt;div class=&quot;col-md-12&quot;&gt;
    &lt;h2&gt;{{ .title }}&lt;/h2&gt;
    &lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt;
        {{ range $item := .items }}
        &lt;tr&gt;
            &lt;td&gt;{{ $item.Content }}&lt;/td&gt;
        &lt;/tr&gt;
        {{ end }}
    &lt;/table&gt;
&lt;/div&gt;
{% endraw %}
</code></pre>

<p>使用 &ldquo;{% raw %}{{ }}{% endraw %}&rdquo; 输出后端发送过来的数据。使用 range 迭代数据。与</p>

<pre><code>for pos, char := range str {
...
}
</code></pre>

<p>一样。</p>

<p>完整的模板代码：</p>

<pre><code>{% raw %}
&lt;!-- public/index.html --&gt;

&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;
        &lt;title&gt;糗百&lt;/title&gt;

        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css&quot;&gt;
        &lt;link rel=&quot;stylesheet&quot;  href=&quot;https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&quot;&gt;

    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;h2&gt;{{ .title }}&lt;/h2&gt;
                    &lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt;
                        {{ range $item := .items }}
                        &lt;tr&gt;
                            &lt;td&gt;{{ $item.Content }}&lt;/td&gt;
                        &lt;/tr&gt;
                        {{ end }}
                    &lt;/table&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
{% endraw %}
</code></pre>

<p>这样，运行一下，就可以了。</p>

<p>gin框架默认使用8080端口，打开 <a href="http://localhost:8080">http://localhost:8080</a> 就可以看到一个极简版的糗百热门了。</p>

<p>问题来了，怎么增加一个分页呢？</p>

<p>完整代码见:</p>

<p><a href="https://github.com/qichengzx/goqiubai">Github地址</a></p>

<h4>后记</h4>

<p>其实早就写完了这篇，但是hexo生成的时候由于 <a href="https://hexo.io/docs/troubleshooting.html#Escape-Contents">&rdquo;{% raw %}{{{% endraw %}&ldquo;的问题</a>，生成一直失败，一直拖到现在。</p>

<p>实际代码中需要去掉 &ldquo;{ % raw % }&rdquo; 相关部分。</p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://qichengzx.github.io/2016/12/04/go-qiubai.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/%e7%b3%97%e7%99%be">糗百</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/goquery">goquery</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/gin">gin</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="21b1d6bb006767ea7ba5a2566c9d7e1b" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://qichengzx.github.io/2016/11/02/install-yaf-on-mac.html" class="article-date">
                      <time itemprop="datePublished">2016-11-02 17:57:38</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/php">php</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://qichengzx.github.io/2016/11/02/install-yaf-on-mac.html">Mac brew php7.1环境下安装Yaf</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p><img src="/images/php/think201-emergence-of-php7.jpg" alt="" /></p>

<p>开发机一直使用brew来安装PHP及其他的环境，今天把PHP升到7.1，由于7.1版本下还没有<a href="http://www.laruence.com/manual/">yaf</a>的源，所以无法使用brew安装，只能编译安装了。</p>

<p>首先下载yaf，解压，进入目录。</p>

<pre><code>git clone git@github.com:laruence/yaf.git

$(brew --prefix homebrew/php/php71)/bin/phpize

./configure --with-php-config=$(brew --prefix homebrew/php/php71)/bin/php-config

make &amp;&amp; make install

make test

</code></pre>

<p>$(brew &ndash;prefix homebrew/php/php71) 即 brew info php71结果中的path值。</p>

<p>由于brew安装PHP会在php.ini同级目录创建conf.d目录，并把扩展的配置文件写在这里，一目了然知道都安装了哪些扩展，所以也以同样方式在此目录创建ext-yaf.ini。</p>

<p>make install 后会显示，具体路径可能会不一样。</p>

<pre><code>Installing shared extensions:     /usr/local/Cellar/php71/7.1.0-rc.5_9/lib/php/extensions/no-debug-non-zts-20160303/
</code></pre>

<p>这个目录即扩展.so的存放目录。下边会用到。</p>

<pre><code>[yaf]
extension=&quot;/usr/local/opt/php71/lib/php/extensions/no-debug-non-zts-20160303/yaf.so&quot;
yaf.environ=&quot;dev&quot;
;yaf.use_namespace = 1
</code></pre>

<p>至此，重启php-fpm就可以了。</p>

<p>图片来自：<a href="https://think201.com/blog/2016/emergence-of-php7/">Emergence of PHP7</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://qichengzx.github.io/2016/11/02/install-yaf-on-mac.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/php">php</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        

        
        


<nav id="page-nav">






  <a class="extend prev" rel="prev" href="/page/2/">« Prev</a>





  <a class="page-number" href="/">1</a>



  <a class="page-number" href="/page/2/">2</a>



  <span class="page-number current">3</span>



  <a class="page-number" href="/page/4/">4</a>



  <a class="page-number" href="/page/5/">5</a>



  <a class="page-number" href="/page/6/">6</a>




  <a class="extend next" rel="next" href="/page/4/">Next »</a>

</nav>


        
      
      </section>
      
      
            <aside id="sidebar">
            
    
                <div class="widget-wrap">
                  <h3 class="widget-title">Categories</h3>
                  <div class="widget">
                    <ul class="category-list">
                      
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/default/">default</a>
                        <span class="category-list-count">8</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/git/">git</a>
                        <span class="category-list-count">3</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/golang/">golang</a>
                        <span class="category-list-count">24</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/javascript/">javascript</a>
                        <span class="category-list-count">7</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/linux/">linux</a>
                        <span class="category-list-count">1</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/mysql/">mysql</a>
                        <span class="category-list-count">4</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/nginx/">nginx</a>
                        <span class="category-list-count">1</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/php/">php</a>
                        <span class="category-list-count">12</span>
                      </li>
                      
                    </ul>
                  </div>
                </div>
    

            
    
                <div class="widget-wrap">
                  <h3 class="widget-title">Tags</h3>
                  <div class="widget">
                    <ul class="tag-list">
                      
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/ECharts/">ECharts</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/Keygen/">Keygen</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/captcha/">captcha</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/crontab/">crontab</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/discuz/">discuz</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/docker/">docker</a>
                        <span class="tag-list-count">2</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/dropbox/">dropbox</a>
                        <span class="tag-list-count">2</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/excel/">excel</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/fetch/">fetch</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/geo/">geo</a>
                        <span class="tag-list-count">3</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/gin/">gin</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/git/">git</a>
                        <span class="tag-list-count">3</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/github/">github</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/go/">go</a>
                        <span class="tag-list-count">24</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/goquery/">goquery</a>
                        <span class="tag-list-count">2</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/hexo/">hexo</a>
                        <span class="tag-list-count">3</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/https/">https</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/input/">input</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/javascript/">javascript</a>
                        <span class="tag-list-count">3</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/js/">js</a>
                        <span class="tag-list-count">2</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/laravel/">laravel</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/leetcode/">leetcode</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/linux/">linux</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/mysql/">mysql</a>
                        <span class="tag-list-count">7</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/nginx/">nginx</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/node/">node</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/pdo/">pdo</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/php/">php</a>
                        <span class="tag-list-count">14</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/qq/">qq</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/rabbitmq/">rabbitmq</a>
                        <span class="tag-list-count">6</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/react-native/">react-native</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/redigo/">redigo</a>
                        <span class="tag-list-count">3</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/redis/">redis</a>
                        <span class="tag-list-count">5</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/ssl/">ssl</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/time/">time</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/vps/">vps</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/vue/">vue</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/widget/">widget</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e4%bb%8a%e6%97%a5%e5%a4%b4%e6%9d%a1/">今日头条</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e6%a0%87%e8%af%86%e7%ac%a6/">标识符</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e7%88%b1%e5%a5%87%e8%89%ba/">爱奇艺</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e7%9f%ad%e7%bd%91%e5%9d%80/">短网址</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e7%b3%97%e7%99%be/">糗百</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e7%bd%91%e7%bb%9c%e8%af%b7%e6%b1%82/">网络请求</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e9%98%9f%e5%88%97/">队列</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                    </ul>
                  </div>
                </div>
    

            
    
            <div class="widget-wrap">
              <h3 class="widget-title">Archives</h3>
              <div class="widget">
                <ul class="archive-list">
                  
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2015/11">2015/11</a>
                    <span class="archive-list-count">7</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2015/12">2015/12</a>
                    <span class="archive-list-count">4</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/01">2016/01</a>
                    <span class="archive-list-count">3</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/02">2016/02</a>
                    <span class="archive-list-count">4</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/04">2016/04</a>
                    <span class="archive-list-count">4</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/05">2016/05</a>
                    <span class="archive-list-count">3</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/07">2016/07</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/09">2016/09</a>
                    <span class="archive-list-count">3</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/10">2016/10</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/11">2016/11</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/12">2016/12</a>
                    <span class="archive-list-count">3</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/03">2017/03</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/06">2017/06</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/07">2017/07</a>
                    <span class="archive-list-count">2</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/08">2017/08</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/09">2017/09</a>
                    <span class="archive-list-count">3</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/11">2017/11</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2018/02">2018/02</a>
                    <span class="archive-list-count">4</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2018/04">2018/04</a>
                    <span class="archive-list-count">2</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2018/05">2018/05</a>
                    <span class="archive-list-count">6</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2018/06">2018/06</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2019/01">2019/01</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2020/02">2020/02</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2021/01">2021/01</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2021/07">2021/07</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                </ul>
              </div>
            </div>
    

            
    
            <div class="widget-wrap">
              <h3 class="widget-title">RECENTS</h3>
              <div class="widget">
                <ul>
                  
                  <li>
                    <a href="https://qichengzx.github.io/2021/07/18/pipeline-pattern-in-go-part-1.html">Go 流水线模式</a>
                  </li>
                  
                  <li>
                    <a href="https://qichengzx.github.io/2021/01/01/unmarshaling-time-values-from-json.html">Go json 时间格式解析</a>
                  </li>
                  
                  <li>
                    <a href="https://qichengzx.github.io/2020/02/02/graceful-shutdown-of-a-tcp-server-in-go.html">优雅的关闭Go TCP Server</a>
                  </li>
                  
                  <li>
                    <a href="https://qichengzx.github.io/2019/01/01/go-in-the-browser.html">【译】Go和WebAssembly：在浏览器中运行Go程序</a>
                  </li>
                  
                  <li>
                    <a href="https://qichengzx.github.io/2018/06/15/qq-007-captcha.html">腾讯防水墙验证码使用</a>
                  </li>
                  
                </ul>
              </div>
            </div>
    

            </aside>

      
    </div>
    
        <footer id="footer">
          <div class="outer">
            <div id="footer-info" class="inner">
              &copy; 2021 启程<br>
              Powered by <a href="https://github.com/qichengzx/gopress" target="_blank">gopress</a>
            </div>
            </div>
        </footer>

  </div>
  
<nav id="mobile-nav">
  
  <a class="mobile-nav-link" href="/">Home</a>
  
  <a class="mobile-nav-link" href="/archives">Archives</a>
  
  <a class="mobile-nav-link" href="https://github.com/qichengzx">GitHub</a>
  
</nav>

  

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>


</div>
</body>
</html>
